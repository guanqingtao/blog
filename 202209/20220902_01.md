## DuckDB 线性回归预测股价的例子  
            
### 作者            
digoal            
            
### 日期            
2022-09-02            
            
### 标签            
PostgreSQL , DuckDB , 线性回归     
            
----            
            
## 背景        
如何预测股价? 除了回归分析统计算法, 还需要有方法论, 找出影响股价的因素, 可以参考华为基本法: 五看三定四配.   
  
- [《PG社区建设方法论 - 五看三定》](../202103/20210329_01.md)       
- [《德说-第122期, 隆中对 - 五看三定四配-华为基本法-战略制定》](../202208/20220811_02.md)    
- [《产品经理 - 以“五看三定”谈产品规划 - 含竞品分析方法》](../202101/20210128_02.md)    
  
影响企业的发展的要素:   
- 企业的生存环境(所处行业相关政策)、  
- 供应链(生产资料、伙伴等, 影响产能、成本等)、  
- 用户(客户所在行业的发展情况, 影响销售)、  
- 友商(竞争, 影响销售)、  
- 所处的行业(影响未来发展趋势)、  
- 自己;   
  
以上要素如何体现数字化呢? 可以从如下几个方面分析:   
- 政策文件, 根据文件影响的范围体现在行业或者大盘指数。所以可以看企业所处行业指数、大盘指数.   
- 供应链, 看企业所处行业的上游的相关行业指数。  
- 用户, 看企业服务的用户群体所属行业的行业指数。  
- 友商, 好坏可能不好评判, 除非它直接影响你. 因为友商好, 也可以解释为行业好.  但是: 友商如果是通过什么技术突破或者商业模式突破抢夺了有限的地盘, 这个就影响可能就是消极的. 甚至是颠覆的, 例如当年电商对线下零售的冲击.  
    - 建议看行业指数    
    - 非数字化的, 建议关注降维打击  
- 行业, 看行业指数。  
- 自己, 直接看自己的股价就好了。  
  
有了这几个输入, 就比较容易实施多元线性回归股价预测。可以根据情况选择里面的指标,   
  
## 算法举例  
根据 “看自己”模型, 只选取自己的每日收盘价, 做一元回归, 预测自己下一天的收盘价.   
  
在数学中，方程式 `Y=a+bX+修正值` , 自变量就是X , 因变量是Y。    
  
自变量是原因，因变量是结果。这个方程式中自变量的变化是因变量变化的原因，自变量是本身会发生变化，而因变量就是根据自变量的变化而变化。  
  
以天为周期, 样本数据例子:   
  
```  
自变量(自立、独立) - independent variable X  
因变量(果, 被预测) - dependent variable Y  
  
(X 昨天, Y 今天) :   
(day-15, day-14)   
(day-14, day-13)   
(day-13, day-12)   
...  
(day-1, day)   
```  
  
公式:  
  
```  
Y = regr_intercept + regr_slope * X  
  
regr_intercept(Y,X), 计算截距.  
  
regr_slope(Y,X), 计算斜率.  
  
regr_r2(Y,X), 计算相关性, 相关性越高, 说明这组数据用于预估的准确度越高.  
```  
  
预测算法:   
  
```  
LOOP 最近4到15天的数据, 自变量是"day"(也就是今天), 因变量是"day-1"(也就是前一天)   
//为什么选取最近4到15天呢? 因为至少要2组数据才能计算, 所以至少需要3天才能构成2组数据: (day-2,day-1), (day-1,day) ,  
//但是两组数就变成直线了, 相关性逼近1, 下一个点必然在直线上, 会导致没有参考意义. 所以至少取3组数字, 那么就需要4天的值:    
//(day-3,day-2), (day-2,day-1), (day-1,day)   
    计算 线性相关性, 截距, 斜率;  
    返回 最大的线性相关性, 以及对应 天数, 原始值list, 截距, 斜率;  
END LOOP;  
根据最近一个周期(天)的值, 截距, 斜率, 预测下一个周期(天)的值;  
返回预测值, 线性相关性, 以及对应 天数, 原始值list, 截距, 斜率;   
  
  
-- 如果停牌, 价格是0, 可以在生成原始数据时, 过滤掉价格是0的日期的数据. 价格通常会波动较大, 没什么可预测性.    
```  
  
最后, 可以对比真实值与预测值的差距;  
  
## DuckDB 一元回归预测例子  
测试到最后, 发现map类型的key不能动态输入, 可能是个bug. 本来map和array_sort是绝配, 根据最佳r2作为key返回对应map的预测值.    
  
```  
v_map = map([r2_list],[predict_result_list])   
  
k = array_sort(r2_list, 'DESC', 'NULLS LAST')[1]  
  
v_map[k]   
```  
  
1、下载茅台的历史收盘价数据:   
https://zhuanlan.zhihu.com/p/65662875  
  
```  
curl "http://quotes.money.163.com/service/chddata.html?code=0600519&start=20010101&end=20220901&fields=TOPEN;TCLOSE" -o ./historical_tradedata_0600519.SH.csv  
```  
  
由于下载过来的文件有编码的问题, 转换处理一下:    
  
```  
$ iconv -f GBK -t UTF-8 ~/Downloads/historical_tradedata_0600519.SH.csv > ~/Downloads/2.csv  
  
$ head -n 5 ~/Downloads/2.csv   
日期,股票代码,名称,开盘价,收盘价  
2022-09-01,'600519,贵州茅台,1912.15,1880.89  
2022-08-31,'600519,贵州茅台,1860.1,1924.0  
2022-08-30,'600519,贵州茅台,1882.35,1870.0  
2022-08-29,'600519,贵州茅台,1883.0,1878.82  
...  
```  
  
导入到duckdb his表:  
  
```  
D create table his (c1 date, c2 text, c3 text, c4 numeric, c5 numeric);  
D copy his from '/Users/digoal/Downloads/2.csv' ( HEADER );  
D select count(*) from his;  
┌──────────────┐  
│ count_star() │  
├──────────────┤  
│ 5101         │  
└──────────────┘  
D select * from his limit 10;  
┌────────────┬─────────┬──────────┬──────────┬──────────┐  
│     c1     │   c2    │    c3    │    c4    │    c5    │  
├────────────┼─────────┼──────────┼──────────┼──────────┤  
│ 2022-09-01 │ '600519 │ 贵州茅台 │ 1912.150 │ 1880.890 │  
│ 2022-08-31 │ '600519 │ 贵州茅台 │ 1860.100 │ 1924.000 │  
│ 2022-08-30 │ '600519 │ 贵州茅台 │ 1882.350 │ 1870.000 │  
│ 2022-08-29 │ '600519 │ 贵州茅台 │ 1883.000 │ 1878.820 │  
│ 2022-08-26 │ '600519 │ 贵州茅台 │ 1900.000 │ 1898.000 │  
│ 2022-08-25 │ '600519 │ 贵州茅台 │ 1859.000 │ 1885.000 │  
│ 2022-08-24 │ '600519 │ 贵州茅台 │ 1869.990 │ 1854.200 │  
│ 2022-08-23 │ '600519 │ 贵州茅台 │ 1898.600 │ 1870.010 │  
│ 2022-08-22 │ '600519 │ 贵州茅台 │ 1885.010 │ 1893.980 │  
│ 2022-08-19 │ '600519 │ 贵州茅台 │ 1898.000 │ 1895.010 │  
└────────────┴─────────┴──────────┴──────────┴──────────┘  
```  
  
删除报价为0的数据  
  
```  
D delete from his where c4 =0 or c5=0;   
D select * from his where c4 =0 or c5=0;   
  
  
  
D select c1, lag(c5) over (order by c1) as yesterday, c5 as today from his order by c1 limit 10;  
┌────────────┬───────────┬────────┐  
│     c1     │ yesterday │ today  │  
├────────────┼───────────┼────────┤  
│ 2001-08-27 │           │ 35.550 │  
│ 2001-08-28 │ 35.550    │ 36.860 │  
│ 2001-08-29 │ 36.860    │ 36.380 │  
│ 2001-08-30 │ 36.380    │ 37.100 │  
│ 2001-08-31 │ 37.100    │ 37.010 │  
│ 2001-09-03 │ 37.010    │ 36.990 │  
│ 2001-09-04 │ 36.990    │ 37.460 │  
│ 2001-09-05 │ 37.460    │ 37.440 │  
│ 2001-09-06 │ 37.440    │ 36.700 │  
│ 2001-09-07 │ 36.700    │ 35.680 │  
└────────────┴───────────┴────────┘  
```  
  
  
使用窗口函数, 帧的概念, 可以获得每一条记录对应的最近N天的数据, 并聚合成数组. 后面就可以用这个数组来做回归运算.  
  
```  
D select c1,   
  array_agg(c5) OVER w as yesterdays,   
  c5 as today from his   
  window   
  w as ( order by c1 ROWS BETWEEN 5 PRECEDING AND -1 FOLLOWING )  
  order by c1 limit 10;   
┌────────────┬──────────────────────────────────────────┬────────┐  
│     c1     │                yesterdays                │ today  │  
├────────────┼──────────────────────────────────────────┼────────┤  
│ 2001-08-27 │                                          │ 35.550 │  
│ 2001-08-28 │ [35.550]                                 │ 36.860 │  
│ 2001-08-29 │ [35.550, 36.860]                         │ 36.380 │  
│ 2001-08-30 │ [35.550, 36.860, 36.380]                 │ 37.100 │  
│ 2001-08-31 │ [35.550, 36.860, 36.380, 37.100]         │ 37.010 │  
│ 2001-09-03 │ [35.550, 36.860, 36.380, 37.100, 37.010] │ 36.990 │  
│ 2001-09-04 │ [36.860, 36.380, 37.100, 37.010, 36.990] │ 37.460 │  
│ 2001-09-05 │ [36.380, 37.100, 37.010, 36.990, 37.460] │ 37.440 │  
│ 2001-09-06 │ [37.100, 37.010, 36.990, 37.460, 37.440] │ 36.700 │  
│ 2001-09-07 │ [37.010, 36.990, 37.460, 37.440, 36.700] │ 35.680 │  
└────────────┴──────────────────────────────────────────┴────────┘  
```  
  
DuckDB提供了类似函数的功能, 也叫宏, 以数组作为输入值, 返回相关性、截距、斜率、预测值. 因而定义以下宏:  
  
```  
create MACRO regr_r2_d3(i) as (select regr_r2(Y, X) from (values (i[1]::double,i[2]::double),(i[2]::double,i[3]::double)) as t(X,Y));  
  
create MACRO regr_intercept_d3(i) as (select regr_intercept(Y, X) from (values (i[1]::double,i[2]::double), (i[2]::double,i[3]::double)) as t(X,Y));  
create MACRO regr_slope_d3(i) as (select regr_slope(Y, X) from (values (i[1]::double,i[2]::double),(i[2]::double,i[3]::double)) as t(X,Y));  
  
create MACRO predict_d3(i) as (  
with t_intercept as (select regr_intercept(Y, X) as regr_intercept from (values (i[1]::double,i[2]::double),(i[2]::double,i[3]::double)) as t(X,Y)),   
t_slope as (select regr_slope(Y, X) as regr_slope from (values (i[1]::double,i[2]::double),(i[2]::double,i[3]::double)) as t(X,Y))   
select regr_intercept + regr_slope * i[3]::double from t_intercept, t_slope  
);  
```  
  
测试算法:   
  
```  
使用这组数据:  
  
│ 2001-08-30 │ [35.550, 36.860, 36.380]                 │ 37.100 │  
```  
  
```  
D select regr_r2_d3(i),regr_intercept_d3(i), regr_slope_d3(i), predict_d3(i) from (values ([35.550, 36.860, 36.380])) as t(i);  
┌────────────────────┬──────────────────────┬──────────────────────┬────────────────────┐  
│   regr_r2_d3(i)    │ regr_intercept_d3(i) │   regr_slope_d3(i)   │   predict_d3(i)    │  
├────────────────────┼──────────────────────┼──────────────────────┼────────────────────┤  
│ 1.0000000000000147 │ 49.88595419847337    │ -0.36641221374046046 │ 36.555877862595416 │  
└────────────────────┴──────────────────────┴──────────────────────┴────────────────────┘  
```  
  
  
接下来把3-15天的predict_d3, regr_r2_d3都写一下:    
  
用PostgreSQL来生成批量SQL语句:  
  
  
```  
create or replace function gen_vals(days int) returns text as $$  
  select string_agg(format('(i[%s]::double,i[%s]::double)', generate_series-1, generate_series),',') from generate_series(2 ,days);  
$$ language sql strict;  
  
postgres=# select gen_vals(3);  
                        gen_vals                           
---------------------------------------------------------  
 (i[1]::double,i[2]::double),(i[2]::double,i[3]::double)  
(1 row)  
  
postgres=# select gen_vals(4);  
                                      gen_vals                                         
-------------------------------------------------------------------------------------  
 (i[1]::double,i[2]::double),(i[2]::double,i[3]::double),(i[3]::double,i[4]::double)  
(1 row)  
```  
  
```  
create or replace function gen_sql_predict(days int) returns text as $$  
  select format ($_$create MACRO predict_d%s(i) as (with t_intercept as (select regr_intercept(Y, X) as regr_intercept from (values %s) as t(X,Y)), t_slope as (select regr_slope(Y, X) as regr_slope from (values %s) as t(X,Y)) select regr_intercept + regr_slope * i[%s]::double from t_intercept, t_slope);$_$, days, gen_vals(days), gen_vals(days), days);   
$$ language sql strict;  
  
create or replace function gen_sql_r2(days int) returns text as $$  
  select format ($_$create MACRO regr_r2_d%s(i) as (select regr_r2(Y, X) from (values %s) as t(X,Y));$_$, days, gen_vals(days));   
$$ language sql strict;  
```  
  
生成SQL文件  
  
```  
IT-C02YW2EFLVDL:release digoal$ psql -t -X -A  
psql (16devel)  
Type "help" for help.  
  
postgres=# \o gen_sql_predict  
postgres=# select gen_sql_predict(i) from generate_series(3,15) i;  
postgres=# \o gen_sql_r2  
postgres=# select gen_sql_r2(i) from generate_series(3,15) i;  
```  
  
在DuckDB中执行以上生成的SQL文件  
  
```  
D   
  
drop macro predict_d3;  
drop macro predict_d4;  
drop macro predict_d5;  
drop macro predict_d6;  
drop macro predict_d7;  
drop macro predict_d8;  
drop macro predict_d9;  
drop macro predict_d10;  
drop macro predict_d11;  
drop macro predict_d12;  
drop macro predict_d13;  
drop macro predict_d14;  
drop macro predict_d15;  
  
drop macro regr_r2_d3;  
drop macro regr_r2_d4;  
drop macro regr_r2_d5;  
drop macro regr_r2_d6;  
drop macro regr_r2_d7;  
drop macro regr_r2_d8;  
drop macro regr_r2_d9;  
drop macro regr_r2_d10;  
drop macro regr_r2_d11;  
drop macro regr_r2_d12;  
drop macro regr_r2_d13;  
drop macro regr_r2_d14;  
drop macro regr_r2_d15;  
  
  
D .read /Users/digoal/duckdb/build/release/gen_sql_predict  
D .read /Users/digoal/duckdb/build/release/gen_sql_r2  
```  
  
接下来, 看一下在一条SQL中, 如何返回4~15天的所有数组, 多加几个帧就可以了  
  
```  
D select c1,   
array_agg(c5) OVER w15 as yester15day,   
array_agg(c5) OVER w14 as yester14day,   
array_agg(c5) OVER w13 as yester13day,   
array_agg(c5) OVER w12 as yester12day,   
array_agg(c5) OVER w11 as yester11day,   
array_agg(c5) OVER w10 as yester10day,   
array_agg(c5) OVER w9 as yester9day,   
array_agg(c5) OVER w8 as yester8day,   
array_agg(c5) OVER w7 as yester7day,   
array_agg(c5) OVER w6 as yester6day,   
array_agg(c5) OVER w5 as yester5day,   
array_agg(c5) OVER w4 as yester4day,   
c5 as today from his   
window   
w15 as ( order by c1 ROWS BETWEEN 15 PRECEDING AND -1 FOLLOWING ),  
w14 as ( order by c1 ROWS BETWEEN 14 PRECEDING AND -1 FOLLOWING ),  
w13 as ( order by c1 ROWS BETWEEN 13 PRECEDING AND -1 FOLLOWING ),  
w12 as ( order by c1 ROWS BETWEEN 12 PRECEDING AND -1 FOLLOWING ),  
w11 as ( order by c1 ROWS BETWEEN 11 PRECEDING AND -1 FOLLOWING ),  
w10 as ( order by c1 ROWS BETWEEN 10 PRECEDING AND -1 FOLLOWING ),  
w9 as ( order by c1 ROWS BETWEEN 9 PRECEDING AND -1 FOLLOWING ),  
w8 as ( order by c1 ROWS BETWEEN 8 PRECEDING AND -1 FOLLOWING ),  
w7 as ( order by c1 ROWS BETWEEN 7 PRECEDING AND -1 FOLLOWING ),  
w6 as ( order by c1 ROWS BETWEEN 6 PRECEDING AND -1 FOLLOWING ),  
w5 as ( order by c1 ROWS BETWEEN 5 PRECEDING AND -1 FOLLOWING ),  
w4 as ( order by c1 ROWS BETWEEN 4 PRECEDING AND -1 FOLLOWING )  
order by c1 limit 10;   
```  
  
  
使用CTE语法, 加上前面建的宏, 可以通过以下SQL计算预测值、相关性.   
  
但是duckdb算了好久没出来, 可能宏套太多了, 效率比较低? 以下SQL用了24个宏.   
  
也可能和这个参数有关: max_expression_depth   https://duckdb.org/docs/sql/configuration   
  
```  
with t1 as (  
select c1,   
array_agg(c5) OVER w15 as yester15day,   
array_agg(c5) OVER w14 as yester14day,   
array_agg(c5) OVER w13 as yester13day,   
array_agg(c5) OVER w12 as yester12day,   
array_agg(c5) OVER w11 as yester11day,   
array_agg(c5) OVER w10 as yester10day,   
array_agg(c5) OVER w9 as yester9day,   
array_agg(c5) OVER w8 as yester8day,   
array_agg(c5) OVER w7 as yester7day,   
array_agg(c5) OVER w6 as yester6day,   
array_agg(c5) OVER w5 as yester5day,   
array_agg(c5) OVER w4 as yester4day,   
c5 as today from his   
window   
w15 as ( order by c1 ROWS BETWEEN 15 PRECEDING AND -1 FOLLOWING ),  
w14 as ( order by c1 ROWS BETWEEN 14 PRECEDING AND -1 FOLLOWING ),  
w13 as ( order by c1 ROWS BETWEEN 13 PRECEDING AND -1 FOLLOWING ),  
w12 as ( order by c1 ROWS BETWEEN 12 PRECEDING AND -1 FOLLOWING ),  
w11 as ( order by c1 ROWS BETWEEN 11 PRECEDING AND -1 FOLLOWING ),  
w10 as ( order by c1 ROWS BETWEEN 10 PRECEDING AND -1 FOLLOWING ),  
w9 as ( order by c1 ROWS BETWEEN 9 PRECEDING AND -1 FOLLOWING ),  
w8 as ( order by c1 ROWS BETWEEN 8 PRECEDING AND -1 FOLLOWING ),  
w7 as ( order by c1 ROWS BETWEEN 7 PRECEDING AND -1 FOLLOWING ),  
w6 as ( order by c1 ROWS BETWEEN 6 PRECEDING AND -1 FOLLOWING ),  
w5 as ( order by c1 ROWS BETWEEN 5 PRECEDING AND -1 FOLLOWING ),  
w4 as ( order by c1 ROWS BETWEEN 4 PRECEDING AND -1 FOLLOWING )  
order by c1 limit 30  
)  
select c1,  
map(  
[regr_r2_d4(yester4day), regr_r2_d5(yester5day), regr_r2_d6(yester6day), regr_r2_d7(yester7day), regr_r2_d8(yester8day), regr_r2_d9(yester9day), regr_r2_d10(yester10day), regr_r2_d11(yester11day), regr_r2_d12(yester12day), regr_r2_d13(yester13day), regr_r2_d14(yester14day), regr_r2_d15(yester15day)],   
[predict_d4(yester4day), predict_d5(yester5day), predict_d6(yester6day), predict_d7(yester7day), predict_d8(yester8day), predict_d9(yester9day), predict_d10(yester10day), predict_d11(yester11day), predict_d12(yester12day), predict_d13(yester13day), predict_d14(yester14day), predict_d15(yester15day)]  
) as v_map,   
today   
from t1   
where   
array_length(yester15day) = 15 -- 避免组数不足, 实际上大于某一天的即可   
limit 1  
;   
```  
  
把计算的宏适当减少后, 执行OK了  
  
```  
with t1 as (  
select c1,   
array_agg(c5) OVER w15 as yester15day,   
array_agg(c5) OVER w14 as yester14day,   
array_agg(c5) OVER w13 as yester13day,   
array_agg(c5) OVER w12 as yester12day,   
array_agg(c5) OVER w11 as yester11day,   
array_agg(c5) OVER w10 as yester10day,   
array_agg(c5) OVER w9 as yester9day,   
array_agg(c5) OVER w8 as yester8day,   
array_agg(c5) OVER w7 as yester7day,   
array_agg(c5) OVER w6 as yester6day,   
array_agg(c5) OVER w5 as yester5day,   
array_agg(c5) OVER w4 as yester4day,  
c5 as today from his   
window   
w15 as ( order by c1 ROWS BETWEEN 15 PRECEDING AND -1 FOLLOWING ),  
w14 as ( order by c1 ROWS BETWEEN 14 PRECEDING AND -1 FOLLOWING ),  
w13 as ( order by c1 ROWS BETWEEN 13 PRECEDING AND -1 FOLLOWING ),  
w12 as ( order by c1 ROWS BETWEEN 12 PRECEDING AND -1 FOLLOWING ),  
w11 as ( order by c1 ROWS BETWEEN 11 PRECEDING AND -1 FOLLOWING ),  
w10 as ( order by c1 ROWS BETWEEN 10 PRECEDING AND -1 FOLLOWING ),  
w9 as ( order by c1 ROWS BETWEEN 9 PRECEDING AND -1 FOLLOWING ),  
w8 as ( order by c1 ROWS BETWEEN 8 PRECEDING AND -1 FOLLOWING ),  
w7 as ( order by c1 ROWS BETWEEN 7 PRECEDING AND -1 FOLLOWING ),  
w6 as ( order by c1 ROWS BETWEEN 6 PRECEDING AND -1 FOLLOWING ),  
w5 as ( order by c1 ROWS BETWEEN 5 PRECEDING AND -1 FOLLOWING ),  
w4 as ( order by c1 ROWS BETWEEN 4 PRECEDING AND -1 FOLLOWING )  
order by c1 limit 30  
)  
select c1,  
[regr_r2_d13(yester13day), regr_r2_d14(yester14day), regr_r2_d15(yester15day)] as v_r2,   
[predict_d13(yester13day), predict_d14(yester14day), predict_d15(yester15day)] as v_predict,   
today   
from t1   
where   
array_length(yester15day) = 15 -- 避免组数不足, 实际上大于某一天的即可   
limit 10  
;   
```  
  
  
```  
with t1 as (  
select c1,   
array_agg(c5) OVER w7 as yester7day,   
array_agg(c5) OVER w6 as yester6day,   
array_agg(c5) OVER w5 as yester5day,   
array_agg(c5) OVER w4 as yester4day,  
c5 as today from his   
window   
w7 as ( order by c1 ROWS BETWEEN 7 PRECEDING AND -1 FOLLOWING ),  
w6 as ( order by c1 ROWS BETWEEN 6 PRECEDING AND -1 FOLLOWING ),  
w5 as ( order by c1 ROWS BETWEEN 5 PRECEDING AND -1 FOLLOWING ),  
w4 as ( order by c1 ROWS BETWEEN 4 PRECEDING AND -1 FOLLOWING )  
order by c1 limit 30  
)  
select c1,  
map(  
[regr_r2_d4(yester4day), regr_r2_d5(yester5day), regr_r2_d6(yester6day), regr_r2_d7(yester7day)],   
[predict_d4(yester4day), predict_d5(yester5day), predict_d6(yester6day), predict_d7(yester7day)]  
) as v_map,   
today   
from t1   
where   
array_length(yester7day) = 7   -- 避免组数不足, 实际上大于某一天的即可   
limit 10  
;  
  
┌────────────┬────────────────────────────────────────────────────────────────────────────────────┬────────┐  
│     c1     │                                       v_map                                        │ today  │  
├────────────┼────────────────────────────────────────────────────────────────────────────────────┼────────┤  
│ 2001-09-05 │ {0.3734599577562011=35.97067961165051, 0.0010750280432829998=37.15281039755352,... │ 37.440 │  
│ 2001-09-06 │ {0.18788685973621247=37.420924964605945, 0.18165092903251495=37.37709205020921,... │ 36.700 │  
│ 2001-09-07 │ {0.23751070374548575=37.67389806512507, 0.05427036342393861=37.32099063578117, ... │ 35.680 │  
│ 2001-09-10 │ {0.8419033154430849=33.76112295664533, 0.37486360499704924=34.778385891862094, ... │ 36.700 │  
│ 2001-09-11 │ {0.008366057708726157=36.354311080758066, 0.10743977231537351=36.59607210626186... │ 36.290 │  
│ 2001-09-12 │ {0.6468746045805402=36.27240196078431, 0.009162357368323229=36.36419982147412, ... │ 35.980 │  
│ 2001-09-13 │ {0.43116230014714724=36.43576300139187, 0.5626690956224882=36.408624645943135, ... │ 35.890 │  
│ 2001-09-14 │ {0.9491498765832811=35.80803986710964, 0.1177043100933379=36.29339547503392, 0.... │ 36.300 │  
│ 2001-09-17 │ {0.25499238378546507=35.92875851627555, 0.08483485202847617=36.12928304705003, ... │ 35.840 │  
│ 2001-09-18 │ {0.5477248881771232=36.19781407035174, 0.4294103279226137=36.178874345549715, 0... │ 36.250 │  
└────────────┴────────────────────────────────────────────────────────────────────────────────────┴────────┘  
Run Time (s): real 0.050 user 0.052647 sys 0.003995  
```  
  
  
建表, 保存所有统计结果:  
  
选择一个日期开始, 确保每一行前面都有足够多的数据用于预测.   
  
```  
D select * from his order by c1 limit 1 offset 15;  
┌────────────┬─────────┬──────────┬────────┬────────┐  
│     c1     │   c2    │    c3    │   c4   │   c5   │  
├────────────┼─────────┼──────────┼────────┼────────┤  
│ 2001-09-17 │ '600519 │ 贵州茅台 │ 36.080 │ 35.840 │  
└────────────┴─────────┴──────────┴────────┴────────┘  
Run Time (s): real 0.002 user 0.001590 sys 0.000147  
```  
  
```  
create table predict_result as   
with t1 as (  
select c1,   
array_agg(c5) OVER w10 as yester10day,   
array_agg(c5) OVER w9 as yester9day,   
array_agg(c5) OVER w8 as yester8day,   
array_agg(c5) OVER w7 as yester7day,   
array_agg(c5) OVER w6 as yester6day,   
array_agg(c5) OVER w5 as yester5day,   
array_agg(c5) OVER w4 as yester4day,   
c5 as today from his   
window   
w10 as ( order by c1 ROWS BETWEEN 10 PRECEDING AND -1 FOLLOWING ),  
w9 as ( order by c1 ROWS BETWEEN 9 PRECEDING AND -1 FOLLOWING ),  
w8 as ( order by c1 ROWS BETWEEN 8 PRECEDING AND -1 FOLLOWING ),  
w7 as ( order by c1 ROWS BETWEEN 7 PRECEDING AND -1 FOLLOWING ),  
w6 as ( order by c1 ROWS BETWEEN 6 PRECEDING AND -1 FOLLOWING ),  
w5 as ( order by c1 ROWS BETWEEN 5 PRECEDING AND -1 FOLLOWING ),  
w4 as ( order by c1 ROWS BETWEEN 4 PRECEDING AND -1 FOLLOWING )   
order by c1   
)  
select c1,  
[regr_r2_d4(yester4day), regr_r2_d5(yester5day), regr_r2_d6(yester6day), regr_r2_d7(yester7day), regr_r2_d8(yester8day), regr_r2_d9(yester9day), regr_r2_d10(yester10day)] as v_r2,   
[predict_d4(yester4day), predict_d5(yester5day), predict_d6(yester6day), predict_d7(yester7day), predict_d8(yester8day), predict_d9(yester9day), predict_d10(yester10day)] as v_predict,   
today   
from t1   
where   
c1 > '2001-09-17'::date   
;   
  
Run Time (s): real 16.186 user 16.351405 sys 0.116249  
```  
  
  
```  
D select count(*) from predict_result;  
┌──────────────┐  
│ count_star() │  
├──────────────┤  
│ 5011         │  
└──────────────┘  
D select * from predict_result limit 10;  
┌────────────┬────────────────────────────────────────────────────────────────────────────────────┬────────────────────────────────────────────────────────────────────────────────────┬────────┐  
│     c1     │                                        v_r2                                        │                                     v_predict                                      │ today  │  
├────────────┼────────────────────────────────────────────────────────────────────────────────────┼────────────────────────────────────────────────────────────────────────────────────┼────────┤  
│ 2001-09-18 │ [0.5477248881771232, 0.4294103279226137, 0.03009429133494708, 0.170296619278861... │ [36.19781407035174, 36.178874345549715, 36.01305389221556, 36.27806672714444, 3... │ 36.250 │  
│ 2001-09-19 │ [0.9611386034911508, 0.6535704666379193, 0.5715803478188309, 0.0014653458030233... │ [35.894709576138155, 35.83907085691977, 35.91483213182286, 36.08960226565418, 3... │ 36.920 │  
│ 2001-09-20 │ [0.0015117174275450366, 0.0029461146679347697, 0.017964714013863896, 4.23991119... │ [36.40301674515962, 36.41369577960143, 36.4792048791507, 36.18644868841496, 36.... │ 36.610 │  
│ 2001-09-21 │ [0.17268457359219136, 0.07695242873659218, 0.08883974063158542, 0.1441959730711... │ [36.66319165638668, 36.486907090977795, 36.48749719476356, 36.46415520954117, 3... │ 36.060 │  
│ 2001-09-24 │ [0.1566366042721039, 0.006366482125359778, 0.018232425919809007, 0.018611120513... │ [36.80417729024607, 36.437406610299774, 36.28947279014742, 36.29932536079288, 3... │ 36.050 │  
│ 2001-09-25 │ [0.6165713402856844, 0.02412225708179192, 0.05680990588985864, 0.04861667900846... │ [35.962677912493405, 36.338516659059785, 36.31826261867725, 36.22388234243884, ... │ 36.230 │  
│ 2001-09-26 │ [0.22128507496296002, 0.4374969015310316, 0.055406903536342936, 0.0758783125403... │ [36.11481824083091, 36.16487413980442, 36.33899769504784, 36.33964143099952, 36... │ 36.080 │  
│ 2001-09-27 │ [0.16394346958076422, 0.20907984305230073, 0.46260944204892124, 0.0767341232139... │ [36.132866449511404, 36.12818712738776, 36.081162388431466, 36.24558100180505, ... │ 36.700 │  
│ 2001-09-28 │ [0.3201373973630739, 0.08695757663985203, 0.16135448117525963, 0.05556990265243... │ [35.23591397849454, 35.639272300469486, 35.993311734422164, 36.36011484529211, ... │ 37.090 │  
│ 2001-10-08 │ [0.39780897600847426, 0.49709615562506027, 0.5522311441310693, 0.15847076815429... │ [37.37150684931507, 37.4154761904762, 37.4830664652568, 36.8382500680378, 36.75... │ 36.580 │  
└────────────┴────────────────────────────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────────────────────────────┴────────┘  
```  
  
使用r2最接近于1的预测值, 对比真实值计算预测准确度.    
  
用sort list, 获得最接近于1的r2 ( r2的取值范围是0到1, 所以没有负数, 没有所谓的负相关性, 这不是corr ) 作为map key, 取得map value  
  
BUG1:  
  
这里发现一个bug: array排序会修改原来的value, 所以map里面的r2也被排序了, 但是predict没有被排序. 这是个大坑.  (把sort放在map后面, 问题依旧.)   
  
issue: https://github.com/duckdb/duckdb/issues/4591   
  
```  
create table t as   
select   
c1,   
today,   
array_sort(v_r2, 'DESC', 'NULLS LAST')[1] as k ,  
map(v_r2, v_predict) as v_map  
from predict_result;   
```  
  
```  
2001-10-08: 0.5522311441310693 本来对应 37.4830664652568  
但是这里变成了 37.37150684931507  
  
D select * from t limit 10;   
┌────────────┬────────┬─────────────────────┬────────────────────────────────────────────────────────────────────────────────────┐  
│     c1     │ today  │          k          │                                       v_map                                        │  
├────────────┼────────┼─────────────────────┼────────────────────────────────────────────────────────────────────────────────────┤  
│ 2001-09-18 │ 36.250 │ 0.5477248881771232  │ {0.5477248881771232=36.19781407035174, 0.4294103279226137=36.178874345549715, 0... │  
│ 2001-09-19 │ 36.920 │ 0.9611386034911508  │ {0.9611386034911508=35.894709576138155, 0.6535704666379193=35.83907085691977, 0... │  
│ 2001-09-20 │ 36.610 │ 0.1591385938539098  │ {0.1591385938539098=36.40301674515962, 0.03630903802451202=36.41369577960143, 0... │  
│ 2001-09-21 │ 36.060 │ 0.17268457359219136 │ {0.17268457359219136=36.66319165638668, 0.14419597307111012=36.486907090977795,... │  
│ 2001-09-24 │ 36.050 │ 0.1566366042721039  │ {0.1566366042721039=36.80417729024607, 0.061351731248072416=36.437406610299774,... │  
│ 2001-09-25 │ 36.230 │ 0.6165713402856844  │ {0.6165713402856844=35.962677912493405, 0.07644244823905755=36.338516659059785,... │  
│ 2001-09-26 │ 36.080 │ 0.4374969015310316  │ {0.4374969015310316=36.11481824083091, 0.22128507496296002=36.16487413980442, 0... │  
│ 2001-09-27 │ 36.700 │ 0.46260944204892124 │ {0.46260944204892124=36.132866449511404, 0.20907984305230073=36.12818712738776,... │  
│ 2001-09-28 │ 37.090 │ 0.3201373973630739  │ {0.3201373973630739=35.23591397849454, 0.16135448117525963=35.639272300469486, ... │  
│ 2001-10-08 │ 36.580 │ 0.5522311441310693  │ {0.5522311441310693=37.37150684931507, 0.49709615562506027=37.4154761904762, 0.... │  
└────────────┴────────┴─────────────────────┴────────────────────────────────────────────────────────────────────────────────────┘  
Run Time (s): real 0.002 user 0.001619 sys 0.000191  
  
D select * from t where k >0.9 limit 10;  
┌────────────┬────────┬────────────────────┬────────────────────────────────────────────────────────────────────────────────────┐  
│     c1     │ today  │         k          │                                       v_map                                        │  
├────────────┼────────┼────────────────────┼────────────────────────────────────────────────────────────────────────────────────┤  
│ 2001-09-19 │ 36.920 │ 0.9611386034911508 │ {0.9611386034911508=35.894709576138155, 0.6535704666379193=35.83907085691977, 0... │  
│ 2001-10-10 │ 36.100 │ 0.9963368695122323 │ {0.9963368695122323=36.28310126582279, 0.2852291723692304=36.861108548363845, 0... │  
│ 2001-10-11 │ 35.750 │ 0.9866335698274049 │ {0.9866335698274049=38.10113785557986, 0.985402510653=38.07037358238826, 0.3093... │  
│ 2001-10-18 │ 34.040 │ 0.9781479987901981 │ {0.9781479987901981=33.712385321100925, 0.7486847756284869=33.54943988050785, 0... │  
│ 2001-10-19 │ 33.500 │ 0.9533950750712719 │ {0.9533950750712719=33.85476923076923, 0.8658318425760284=33.81948497854077, 0.... │  
│ 2001-10-22 │ 32.790 │ 0.9477912047935907 │ {0.9477912047935907=33.285365448504976, 0.8833241316339207=33.1913194375187, 0.... │  
│ 2001-10-23 │ 36.070 │ 0.9510735325285963 │ {0.9510735325285963=31.57185332011894, 0.9500656419423904=32.14222371025968, 0.... │  
│ 2001-11-15 │ 33.680 │ 0.9361801792676424 │ {0.9361801792676424=33.64224388514711, 0.6009975066046721=33.79353325643983, 0.... │  
│ 2001-11-19 │ 35.050 │ 0.9674148245577682 │ {0.9674148245577682=38.84000000000003, 0.633792497858624=36.10839694656508, 0.2... │  
│ 2001-11-20 │ 35.380 │ 0.9522489742995084 │ {0.9522489742995084=37.73210424710417, 0.9458826283979601=37.87320042342975, 0.... │  
└────────────┴────────┴────────────────────┴────────────────────────────────────────────────────────────────────────────────────┘  
Run Time (s): real 0.001 user 0.001354 sys 0.000137  
```  
  
以下SQL预期的是取出v_map中r2最大时对应的预测值.   
  
BUG2:   
  
但是可能又是个bug: 貌似只取了一个k的value后, 传入的k都是固定的(不确定).     
  
issue: https://github.com/duckdb/duckdb/issues/4590  
  
```  
D select c1,k,v_map,v_map[k] from t order by c1 limit 10;  
┌─────────────────────┐  
│      v_map[k]       │  
├─────────────────────┤  
│ [36.19781407035174] │  
│ []                  │  
│ []                  │  
│ []                  │  
│ []                  │  
│ []                  │  
│ []                  │  
│ []                  │  
│ []                  │  
│ []                  │  
└─────────────────────┘  
Run Time (s): real 0.001 user 0.001363 sys 0.000067  
  
D select element_at(v_map, k) from t limit 5;  
┌──────────────────────┐  
│ element_at(v_map, k) │  
├──────────────────────┤  
│ [36.19781407035174]  │  
│ []                   │  
│ []                   │  
│ []                   │  
│ []                   │  
└──────────────────────┘  
Run Time (s): real 0.002 user 0.001522 sys 0.000111  
```  
  
  
那就先建2张表, 一张存储sort后的key, 一张存储未sort的map.  
  
```  
create table t1 as   
select   
c1,   
today,   
array_sort(v_r2, 'DESC', 'NULLS LAST')[1] as k   
from predict_result;   
  
create table t2 as   
select   
c1,   
map(v_r2, v_predict) as v_map  
from predict_result;   
  
  
D select * from t1 limit 10;  
┌────────────┬────────┬─────────────────────┐  
│     c1     │ today  │          k          │  
├────────────┼────────┼─────────────────────┤  
│ 2001-09-18 │ 36.250 │ 0.5477248881771232  │  
│ 2001-09-19 │ 36.920 │ 0.9611386034911508  │  
│ 2001-09-20 │ 36.610 │ 0.1591385938539098  │  
│ 2001-09-21 │ 36.060 │ 0.17268457359219136 │  
│ 2001-09-24 │ 36.050 │ 0.1566366042721039  │  
│ 2001-09-25 │ 36.230 │ 0.6165713402856844  │  
│ 2001-09-26 │ 36.080 │ 0.4374969015310316  │  
│ 2001-09-27 │ 36.700 │ 0.46260944204892124 │  
│ 2001-09-28 │ 37.090 │ 0.3201373973630739  │  
│ 2001-10-08 │ 36.580 │ 0.5522311441310693  │  
└────────────┴────────┴─────────────────────┘  
Run Time (s): real 0.001 user 0.000640 sys 0.000075  
  
D select * from t2 limit 10;  
┌────────────┬────────────────────────────────────────────────────────────────────────────────────┐  
│     c1     │                                       v_map                                        │  
├────────────┼────────────────────────────────────────────────────────────────────────────────────┤  
│ 2001-09-18 │ {0.5477248881771232=36.19781407035174, 0.4294103279226137=36.178874345549715, 0... │  
│ 2001-09-19 │ {0.9611386034911508=35.894709576138155, 0.6535704666379193=35.83907085691977, 0... │  
│ 2001-09-20 │ {0.0015117174275450366=36.40301674515962, 0.0029461146679347697=36.413695779601... │  
│ 2001-09-21 │ {0.17268457359219136=36.66319165638668, 0.07695242873659218=36.486907090977795,... │  
│ 2001-09-24 │ {0.1566366042721039=36.80417729024607, 0.006366482125359778=36.437406610299774,... │  
│ 2001-09-25 │ {0.6165713402856844=35.962677912493405, 0.02412225708179192=36.338516659059785,... │  
│ 2001-09-26 │ {0.22128507496296002=36.11481824083091, 0.4374969015310316=36.16487413980442, 0... │  
│ 2001-09-27 │ {0.16394346958076422=36.132866449511404, 0.20907984305230073=36.12818712738776,... │  
│ 2001-09-28 │ {0.3201373973630739=35.23591397849454, 0.08695757663985203=35.639272300469486, ... │  
│ 2001-10-08 │ {0.39780897600847426=37.37150684931507, 0.49709615562506027=37.4154761904762, 0... │  
└────────────┴────────────────────────────────────────────────────────────────────────────────────┘  
Run Time (s): real 0.001 user 0.001226 sys 0.000157  
```  
  
  
拆成2张表之后, 好像问题还是存在:  
  
```  
select t1.c1,t1.today,t1.k,t2.v_map from t1 join t2 on t1.c1=t2.c1 order by t1.c1 limit 10;  
  
D select t1.c1,t1.today,t1.k,t2.v_map from t1 join t2 on t1.c1=t2.c1 order by t1.c1 limit 10;  
┌────────────┬────────┬─────────────────────┬────────────────────────────────────────────────────────────────────────────────────┐  
│     c1     │ today  │          k          │                                       v_map                                        │  
├────────────┼────────┼─────────────────────┼────────────────────────────────────────────────────────────────────────────────────┤  
│ 2001-09-18 │ 36.250 │ 0.5477248881771232  │ {0.5477248881771232=36.19781407035174, 0.4294103279226137=36.178874345549715, 0... │  
│ 2001-09-19 │ 36.920 │ 0.9611386034911508  │ {0.9611386034911508=35.894709576138155, 0.6535704666379193=35.83907085691977, 0... │  
│ 2001-09-20 │ 36.610 │ 0.1591385938539098  │ {0.0015117174275450366=36.40301674515962, 0.0029461146679347697=36.413695779601... │  
│ 2001-09-21 │ 36.060 │ 0.17268457359219136 │ {0.17268457359219136=36.66319165638668, 0.07695242873659218=36.486907090977795,... │  
│ 2001-09-24 │ 36.050 │ 0.1566366042721039  │ {0.1566366042721039=36.80417729024607, 0.006366482125359778=36.437406610299774,... │  
│ 2001-09-25 │ 36.230 │ 0.6165713402856844  │ {0.6165713402856844=35.962677912493405, 0.02412225708179192=36.338516659059785,... │  
│ 2001-09-26 │ 36.080 │ 0.4374969015310316  │ {0.22128507496296002=36.11481824083091, 0.4374969015310316=36.16487413980442, 0... │  
│ 2001-09-27 │ 36.700 │ 0.46260944204892124 │ {0.16394346958076422=36.132866449511404, 0.20907984305230073=36.12818712738776,... │  
│ 2001-09-28 │ 37.090 │ 0.3201373973630739  │ {0.3201373973630739=35.23591397849454, 0.08695757663985203=35.639272300469486, ... │  
│ 2001-10-08 │ 36.580 │ 0.5522311441310693  │ {0.39780897600847426=37.37150684931507, 0.49709615562506027=37.4154761904762, 0... │  
└────────────┴────────┴─────────────────────┴────────────────────────────────────────────────────────────────────────────────────┘  
Run Time (s): real 0.017 user 0.016902 sys 0.000992  
  
  
select t1.c1,t1.today,t1.k,t2.v_map[t1.k] from t1 join t2 on t1.c1=t2.c1 order by t1.c1 limit 10;  
  
  
D select t1.c1,t1.today,t1.k,t2.v_map[t1.k] from t1 join t2 on t1.c1=t2.c1 order by t1.c1 limit 10;  
┌────────────┬────────┬─────────────────────┬─────────────────────┐  
│     c1     │ today  │          k          │   t2.v_map[t1.k]    │  
├────────────┼────────┼─────────────────────┼─────────────────────┤  
│ 2001-09-18 │ 36.250 │ 0.5477248881771232  │ [36.19781407035174] │  
│ 2001-09-19 │ 36.920 │ 0.9611386034911508  │ []                  │  
│ 2001-09-20 │ 36.610 │ 0.1591385938539098  │ []                  │  
│ 2001-09-21 │ 36.060 │ 0.17268457359219136 │ []                  │  
│ 2001-09-24 │ 36.050 │ 0.1566366042721039  │ []                  │  
│ 2001-09-25 │ 36.230 │ 0.6165713402856844  │ []                  │  
│ 2001-09-26 │ 36.080 │ 0.4374969015310316  │ []                  │  
│ 2001-09-27 │ 36.700 │ 0.46260944204892124 │ []                  │  
│ 2001-09-28 │ 37.090 │ 0.3201373973630739  │ [35.23591397849454] │  
│ 2001-10-08 │ 36.580 │ 0.5522311441310693  │ [37.4830664652568]  │  
└────────────┴────────┴─────────────────────┴─────────────────────┘  
Run Time (s): real 0.015 user 0.014920 sys 0.000168  
  
  
D select v_map[0.9611386034911508] from t2 where c1='2001-09-19';  
┌───────────────────────────┐  
│ v_map[0.9611386034911508] │  
├───────────────────────────┤  
│ [35.894709576138155]      │  
└───────────────────────────┘  
Run Time (s): real 0.001 user 0.000808 sys 0.000075  
  
  
D select v_map[0.5477248881771232] from t2 where c1='2001-09-28';  
┌───────────────────────────┐  
│ v_map[0.5477248881771232] │  
├───────────────────────────┤  
│ []                        │  
└───────────────────────────┘  
Run Time (s): real 0.000 user 0.000415 sys 0.000035  
D select v_map[0.3201373973630739] from t2 where c1='2001-09-28';  
┌───────────────────────────┐  
│ v_map[0.3201373973630739] │  
├───────────────────────────┤  
│ [35.23591397849454]       │  
└───────────────────────────┘  
Run Time (s): real 0.001 user 0.000901 sys 0.000072  
  
  
D pragma worker_threads=1;  
  
D select t1.c1,t1.today,t1.k,t2.v_map[t1.k] from t1 join t2 on t1.c1=t2.c1 order by t1.c1 limit 10;  
┌────────────┬────────┬─────────────────────┬─────────────────────┐  
│     c1     │ today  │          k          │   t2.v_map[t1.k]    │  
├────────────┼────────┼─────────────────────┼─────────────────────┤  
│ 2001-09-18 │ 36.250 │ 0.5477248881771232  │ [36.19781407035174] │  
│ 2001-09-19 │ 36.920 │ 0.9611386034911508  │ []                  │  
│ 2001-09-20 │ 36.610 │ 0.1591385938539098  │ []                  │  
│ 2001-09-21 │ 36.060 │ 0.17268457359219136 │ []                  │  
│ 2001-09-24 │ 36.050 │ 0.1566366042721039  │ []                  │  
│ 2001-09-25 │ 36.230 │ 0.6165713402856844  │ []                  │  
│ 2001-09-26 │ 36.080 │ 0.4374969015310316  │ []                  │  
│ 2001-09-27 │ 36.700 │ 0.46260944204892124 │ []                  │  
│ 2001-09-28 │ 37.090 │ 0.3201373973630739  │ [35.23591397849454] │  
│ 2001-10-08 │ 36.580 │ 0.5522311441310693  │ [37.4830664652568]  │  
└────────────┴────────┴─────────────────────┴─────────────────────┘  
Run Time (s): real 0.015 user 0.014968 sys 0.000158  
```  
  
## 补充,BUG2修复后的补充
把r2和map分开存储, 避免bug1的影响, 用一个表得到预测结果.   
  
```
drop table predict_result;

create table predict_result as   
with t1 as (  
select c1,   
array_agg(c5) OVER w10 as yester10day,   
array_agg(c5) OVER w9 as yester9day,   
array_agg(c5) OVER w8 as yester8day,   
array_agg(c5) OVER w7 as yester7day,   
array_agg(c5) OVER w6 as yester6day,   
array_agg(c5) OVER w5 as yester5day,   
array_agg(c5) OVER w4 as yester4day,   
c5 as today from his   
window   
w10 as ( order by c1 ROWS BETWEEN 10 PRECEDING AND -1 FOLLOWING ),  
w9 as ( order by c1 ROWS BETWEEN 9 PRECEDING AND -1 FOLLOWING ),  
w8 as ( order by c1 ROWS BETWEEN 8 PRECEDING AND -1 FOLLOWING ),  
w7 as ( order by c1 ROWS BETWEEN 7 PRECEDING AND -1 FOLLOWING ),  
w6 as ( order by c1 ROWS BETWEEN 6 PRECEDING AND -1 FOLLOWING ),  
w5 as ( order by c1 ROWS BETWEEN 5 PRECEDING AND -1 FOLLOWING ),  
w4 as ( order by c1 ROWS BETWEEN 4 PRECEDING AND -1 FOLLOWING )   
order by c1   
), 
t2 as (
select c1,  
[regr_r2_d4(yester4day), regr_r2_d5(yester5day), regr_r2_d6(yester6day), regr_r2_d7(yester7day), regr_r2_d8(yester8day), regr_r2_d9(yester9day), regr_r2_d10(yester10day)] as v_r2,   
[predict_d4(yester4day), predict_d5(yester5day), predict_d6(yester6day), predict_d7(yester7day), predict_d8(yester8day), predict_d9(yester9day), predict_d10(yester10day)] as v_predict,   
today   
from t1   
where   
c1 > '2001-09-17'::date   
)
select c1, today, v_r2, map(v_r2,v_predict) as v_map from t2;

select c1,today,v_map[(array_sort(v_r2,'DESC','NULLS LAST')[1])][1] as predict from predict_result limit 10;

┌────────────┬────────┬────────────────────┐
│     c1     │ today  │      predict       │
├────────────┼────────┼────────────────────┤
│ 2001-09-18 │ 36.250 │ 36.19781407035174  │
│ 2001-09-19 │ 36.920 │ 35.894709576138155 │
│ 2001-09-20 │ 36.610 │ 35.87527833001987  │
│ 2001-09-21 │ 36.060 │ 36.66319165638668  │
│ 2001-09-24 │ 36.050 │ 36.80417729024607  │
│ 2001-09-25 │ 36.230 │ 35.962677912493405 │
│ 2001-09-26 │ 36.080 │ 36.16487413980442  │
│ 2001-09-27 │ 36.700 │ 36.081162388431466 │
│ 2001-09-28 │ 37.090 │ 35.23591397849454  │
│ 2001-10-08 │ 36.580 │ 37.4830664652568   │
└────────────┴────────┴────────────────────┘
Run Time (s): real 0.004 user 0.003137 sys 0.000061
```
    
    
## 参考  
https://duckdb.org/docs/sql/statements/create_macro  
  
- [《在PostgreSQL中用线性回归分析(linear regression) - 实现数据预测 - 股票预测例子》](../201503/20150303_01.md)    
- [《PostgreSQL 线性回归 - 股价预测 1》](../201503/20150304_01.md)    
- [《在PostgreSQL中用线性回归分析linear regression做预测 - 例子2, 预测未来数日某股收盘价》](../201503/20150305_01.md)    
- [《PostgreSQL 多元线性回归 - 2 股票预测》](../201512/20151214_01.md)    
- [《PostgreSQL KPI 预测例子 - 线性回归, 斜率, 截距, 相关性, regr_slope, regr_intercept, regr_r2》](../201904/20190426_01.md)    
  
还有一个比较复杂的, 使用分形和长相关性分析H值, 了解当前适合回归预测模型还是线性相关预测模型.   
- https://baijiahao.baidu.com/s?id=1698975972599231718  
  
  
#### [期望 PostgreSQL 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB for PostgreSQL云原生分布式开源数据库](https://github.com/ApsaraDB/PolarDB-for-PostgreSQL "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PostgreSQL 解决方案集合](https://yq.aliyun.com/topic/118 "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
  
#### [PolarDB 学习图谱: 训练营、培训认证、在线互动实验、解决方案、生态合作、写心得拿奖品](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [购买PolarDB云服务折扣活动进行中, 55元起](https://www.aliyun.com/activity/new/polardb-yunparter?userCode=bsb3t4al "e0495c413bedacabb75ff1e880be465a")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
